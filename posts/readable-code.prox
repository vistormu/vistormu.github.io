@title{Vistor's Blog: Readable Python Code}
@style{./../style.css}

@post-header

@h1
How To Write Readable Code in Python

@line

@subtitle
Published on @mark{nov 6th 2023}. Last edit on @mark{nov 6th 2023}.

@spacer

@divider

Have you ever returned to a project you haven't worked on in a while and had no idea what you were doing? Or maybe you've been working on a project with a team and you have no idea what your teammates code does? If you have, then you know how important it is to write readable code.

@divider

@h2
Table of Contents

@list{
@url{\#example-code}{Example Code}
}{
@url{\#use-descriptive-variable-names}{Use descriptive variable names}
}{
@url{\#write-procedural-code}{Write Procedural Code}
}{
@url{\#use-type-hints}{Use Type Hints}
}{
@url{\#avoid-using-comments}{Avoid Using Comments}
}{
@url{\#use-docstrings}{Use Docstrings}
}{
@url{\#wrapping-up}{Wrapping Up}
}{
@url{\#recommended-posts}{Recommended posts}
}

@spacer

@divider

@h2
Example Code

We will be using this simple code snippet as an example throughout this post. This code defines a class called @mark{Foo} with two methods: @mark{bar} and @mark{baz}. A priori, it is not clear what this code does. We can make it more readable by following the tips below.

@spacer

@pre
class Foo:<br>
    def __init__(self, a, b):<br>
        self.a = a<br>
        self.b = b<br>
<br>
    def bar(self):<br>
        return np.pi*np.power(self.a, 2)*self.b<br>
<br>
    def baz(self):<br>
        return 2*np.pi*self.a*self.b + 2*np.pi*np.power(self.a, 2)


@divider

@h2
Use descriptive variable names

The first step to writing readable code is to use descriptive variable names.

There is a famous quote by Phil Karlton that says: "There are only two hard things in Computer Science: cache invalidation and naming things". The seemingly simple task of choosing clear and meaningful names for variables can be surprisingly challenging. In our example is a piece of cake:

@list{
The class @mark{Foo} represents a Cylinder.<br>
}{
The variable @mark{a} represents the radius of the cylinder.<br>
}{
The variable @mark{b} represents the height of the cylinder.<br>
}{
The method @mark{bar} computes the volume of the cylinder.<br>
}{
The method @mark{baz} computes the area of the cylinder.<br>
}

Making these changes, our code becomes much more readable:

@spacer

@pre
class Cylinder:<br>
    def __init__(self, radius, height):<br>
        self.radius = radius<br>
        self.height = height<br>
<br>
    def volume(self):<br>
        return np.pi*np.power(self.radius, 2)*self.height<br>
<br>
    def area(self):<br>
        return 2*np.pi*self.radius*self.height + 2*np.pi*np.power(self.radius, 2)

@divider

@h2
Write Procedural Code

Always try to write procedural code.

Try to divide the code in many steps as necessary. You are not a better programmer for writing more one-liners. It is often more befenicial to be clear than the minuscule optimization you might achieve.

In our example, despite of being a simple piece of code, I hope the point is clear. We can divide the @mark{area} method result into two calculations: one for the lateral area and one for the base area. This further explains what the code does and makes it more readable:

@spacer

@pre
class Cylinder:<br>
    def __init__(self, radius, height):<br>
        self.radius = radius<br>
        self.height = height<br>
<br>
    def volume(self):<br>
        return np.pi*np.power(self.radius, 2)*self.height<br>
<br>
    def area(self):<br>
        lateral_area = 2*np.pi*self.radius*self.height<br>
        base_area = 2*np.pi*np.power(self.radius, 2)<br>
        return lateral_area + base_area

@divider

@h2
Use Type Hints

Python is an interpreted language, meaning that it is a loosey-goofey language. If you pass to the cylinder constructor a boolean variable, Python will not even blink. The program will just panic during runtime, which sometimes is very annoying. 

To avoid these kinds of mistakes, one would normally use a Language Server Protocol (LSP) to get a real-time feedback on errors. There are many LSPs for Python, like Pylance or Pyright, and they are really nice. LSPs will try their best to catch these errors, but they are not foolproof.

Type hinting has a double purpose: help the LSPs do their work better and help the programmer understand the code better.

In our example, we can add type hints to the arguments of all methods, the class' attributes and the variable declaration in the @mark{area} method. In case of passing a wrong argument type, our LSP will warn us.

@spacer

@pre
class Cylinder:<br>
    def __init__(self, radius: float, height: float) -> None:<br>
        self.radius: float = radius<br>
        self.height: float = height<br>
<br>
    def volume(self) -> float:<br>
        return np.pi*np.power(self.radius, 2)*self.height<br>
<br>
    def area(self) -> float:<br>
        lateral_area: float = 2*np.pi*self.radius*self.height<br>
        base_area: float = 2*np.pi*np.power(self.radius, 2)<br>
        return lateral_area + base_area

@divider

@h2
Avoid Using Comments

Comments are not for documenting your code.

Comments are for explaining why you did something, not what you did. If you need to explain what you did, then you should refactor your code to make it more readable.

In our example there is not much to say, but to make the point clearer, we could annotate the choice of using NumPy instead of the built-in @mark{**}, for example.

@spacer

@pre
class Cylinder:<br>
    def __init__(self, radius: float, height: float) -> None:<br>
        self.radius: float = radius<br>
        self.height: float = height<br>
<br>
    def volume(self) -> float:<br>
        \# np.power is faster than ** <br>
        return np.pi*np.power(self.radius, 2)*self.height<br>
<br>
    def area(self) -> float:<br>
        lateral_area: float = 2*np.pi*self.radius*self.height<br>
        base_area: float = 2*np.pi*np.power(self.radius, 2)<br>
        return lateral_area + base_area

@divider

@h2
Use Docstrings

Docstrings are for documenting your code.

The ultimate way of documenting your code is to use Docstrings. Docstrings are strings that are placed right after the declaration of a function, class or method, and are used to describe what the function, class or method does. The main advantage of using Docstrings is that your LSP will show them ot you, saving lots of time on checking external documentation.

It makes the code much more chunky, so I recommend using them for objects exposed by your API.

If you want more information, check out my post on @url{./docstrings.html}{How To Document Your Python Code with Docstrings}.

@spacer

@pre
class Cylinder:<br>
    '''<br>
    A class to represent a cylinder.<br>
    '''<br>
    def __init__(self, radius: float, height: float) -> None:<br>
        '''<br>
        Parameters<br>
        ----------<br>
        radius : float<br>
            The radius of the cylinder.<br>
        height : float<br>
            The height of the cylinder.<br>
        '''<br>
        self.radius: float = radius<br>
        self.height: float = height<br>
<br>
    def volume(self) -> float:<br>
        '''<br>
        Computes the volume of the cylinder.<br>
<br>
        Returns<br>
        -------<br>
        float<br>
            The volume of the cylinder.<br>
        '''<br>
        \# np.power is faster than **<br>
        return np.pi*np.power(self.radius, 2)*self.height<br>
<br>
    def area(self) -> float:<br>
        '''<br>
        Computes the area of the cylinder.<br>
<br>
        Returns<br>
        -------<br>
        float<br>
            The area of the cylinder.<br>
        '''<br>
        lateral_area: float = 2*np.pi*self.radius*self.height<br>
        base_area: float = 2*np.pi*np.power(self.radius, 2)<br>
        return lateral_area + base_area

@divider

@h2
Wrapping Up

Writing readable code is a skill that takes time to master. It is not easy to write code that is both readable and efficient. But, as with everything in life, practice makes perfect. The more you write code, the better you will get at it.

Thanks for reading!

@divider

@h2
Recommended Posts

If you liked this post, you might also like

<div class="card-row">

@card{
How To Document Your Python Code with Docstrings
}{
Learn how to document your Python code with Docstrings to enhance your APIs.
}{
nov 6th 2023
}{
./docstrings.html
}

@card{
How To Create a Python Virtual Environment with Conda
}{
Learn how to create a Python Virtual Environment with Conda to manage your Python version and libraries.
}{
oct 11th 2023
}{
./conda.html
}

</div>

@post-footer

<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="/css/output.css">
<link id="highlight-style" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.0/styles/atom-one-dark.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.0/highlight.min.js"></script>
</head>
<body>
<header>
        
<nav class="flex justify-evenly max-w-4xl mx-auto p-4">
            
<a class="text-lg font-semibold text-white no-underline" href="/index.html">about</a>
            
<a class="text-lg font-semibold text-white no-underline" href="/html/projects.html">projects</a>
            
<a class="text-lg font-semibold text-white no-underline" href="/html/tutorials.html">tutorials</a>
            
<a class="text-lg font-semibold text-white no-underline" href="/html/blog.html">blog</a>
        </nav>
    </header>
    
<div class="max-w-4xl mx-auto px-8">
<h1 class="text-3xl font-bold mt-8 mb-4 text-center text-violet" id="snake-game-in-the-terminal-using-go">Snake Game in the Terminal using Go</h1>
<div class="text-sm text-center mb-16">
        
<span>published on 
<mark class="bg-gray text-white">mar 18th 2024</mark></span>
        •
        
<span>last edited on 
<mark class="bg-gray text-white">mar 18th 2024</mark></span>
        •
        
<span>
<mark class="bg-gray text-white">30 min</mark> read</span>
    </div>
<p>
	The terminal is a powerful tool that can be used for more than just running commands. In this tutorial, we will create a simple snake game that runs in the terminal using Go; no dependencies, no assets. Although the game could be done in a single script, I will break it down into multiple files so that we can learn how to structure a Go project.
</p>
<p>
	Each go module will be responsible for a different part of the game. We will have a module for the terminal, one for reading the user's input, one for the game logic, and one for rendering.
</p>
<p>
	Let's get started!
</p>
<h2 class="text-2xl mt-16 mb-4 text-red font-bold" id="table-of-contents">
	Table of Contents
</h2>
<ul class="list-none list-inside mb-8">
<li>-&gt;&nbsp;
<a href="#setup">Setup</a></li>
<li>-&gt;&nbsp;
<a href="#entering-raw-mode">Entering Raw Mode</a></li>
<li>-&gt;&nbsp;
<a href="#keyboard-input">Keyboard Input</a></li>
<li>-&gt;&nbsp;
<a href="#game-loop-and-rendering">Game Loop and Rendering</a></li>
<li>-&gt;&nbsp;
<a href="#the-snake">The Snake</a></li>
<li>-&gt;&nbsp;
<a href="#food-and-game-over">Food and Game Over</a></li>
<li>-&gt;&nbsp;
<a href="#wrapping-up">Wrapping Up</a></li>
</ul>
<h2 class="text-2xl mt-16 mb-4 text-red font-bold" id="setup">
	Setup
</h2>
<p>
	Before we start, make sure you have Go installed on your machine, our only dependency for this project. If you don't have it installed, you can download it from 
<a href="https://go.dev/doc/install">the official website</a>.
</p>
<p>
	Then, create a new directory for the project and navigate to it.
</p>
<div class="text-orange mt-4 text-sm">terminal</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-bash">mkdir snake-game
cd snake-game</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<p>
	To start a new Go project, we need to create a new module. We can do this by running the following command.
</p>
<div class="text-orange mt-4 text-sm">terminal</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-bash">go mod init snake</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<p>
	This will create a new file called 
<mark class="bg-gray text-white">go.mod</mark> in the current directory. This file is used to define the module and its dependencies.
</p>
<p>
	Now that we have our module set up, we can start writing the code for our game. Let's start by creating a new file called 
<mark class="bg-gray text-white">main.go</mark> and adding some temporary code to it.
</p>
<div class="text-orange mt-4 text-sm">main.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">package main
    
import (
    "fmt"
)
    
func main() {
    fmt.Println("Hello, World!")
}</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<h2 class="text-2xl mt-16 mb-4 text-red font-bold" id="entering-raw-mode">
	Entering Raw Mode
</h2>
<p>
	By default, the terminal is in 
<mark class="bg-gray text-white">canonical mode</mark>. This means that the terminal waits for the user to press 
<mark class="bg-gray text-white">Enter</mark> before sending the input to the program. This is not suitable for games, as we want to process the input as soon as the user presses a key. To do this, we need to put the terminal in 
<mark class="bg-gray text-white">raw mode</mark>.
</p>
<h3 class="text-xl mt-8 text-green" id="storing-terminal-attributes">
	Storing Terminal Attributes
</h3>
<p>
	Let's create a new directory called 
<mark class="bg-gray text-white">terminal</mark> and add a new file called 
<mark class="bg-gray text-white">termios.go</mark> to it. This file will contain a struct called 
<mark class="bg-gray text-white">Termios</mark> that we will use to store the terminal attributes.
</p>
<div class="text-orange mt-4 text-sm">terminal/termios.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">package terminal
    
type Termios struct {
    Iflag, Oflag, Cflag, Lflag uint32
    Cc [20]byte
    Ispeed, Ospeed uint32
}</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<mark class="bg-gray text-white">Iflag</mark>, 
<mark class="bg-gray text-white">Oflag</mark>, 
<mark class="bg-gray text-white">Cflag</mark>, and 
<mark class="bg-gray text-white">Lflag</mark> are used to store the input, output, control, and local modes, respectively. 
<mark class="bg-gray text-white">Cc</mark> is used to store the control characters. 
<mark class="bg-gray text-white">Ispeed</mark> and 
<mark class="bg-gray text-white">Ospeed</mark> are used to store the input and output baud rates.
<p>
	The next step is to create a new function called 
<mark class="bg-gray text-white">getTermios</mark> that will return the current terminal attributes. For this, we will use the 
<mark class="bg-gray text-white">syscall</mark> and 
<mark class="bg-gray text-white">unsafe</mark> packages.
</p>
<div class="text-orange mt-4 text-sm">terminal/termios.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">package terminal
    
import (
    "syscall"
    "unsafe"
)</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<div class="text-orange mt-4 text-sm">terminal/termios.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">func getTermios(fd uintptr) (*Termios, error) {
    termios := &Termios{}
    _, _, errno := syscall.Syscall(syscall.SYS_IOCTL, fd, syscall.TCGETS, uintptr(unsafe.Pointer(termios)))
    if errno != 0 {
        return nil, errno
    }
    
    return termios, nil
}</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<p>
	This function accepts a file descriptor 
<mark class="bg-gray text-white">fd</mark> as an argument, which is used to identify the terminal. We initialize a new 
<mark class="bg-gray text-white">Termios</mark> struct and use the 
<mark class="bg-gray text-white">syscall.Syscall</mark> function to make a system call to 
<mark class="bg-gray text-white">ioctl</mark> (input/output control) with 
<mark class="bg-gray text-white">syscall.TCGETS</mark> indicating that the current settings of the terminal are to be read. The memory address of the 
<mark class="bg-gray text-white">Termios</mark> struct is passed to 
<mark class="bg-gray text-white">ioctl</mark> through 
<mark class="bg-gray text-white">unsafe.Pointer</mark>, facilitating direct memory manipulation. If the operation is successful, the function returns a pointer to a 
<mark class="bg-gray text-white">Termios</mark> struct populated with the current terminal settings. If there's an error (indicated by a non-zero 
<mark class="bg-gray text-white">errno</mark>), an error is returned instead.
</p>
<p>
	For setting back the terminal attributes given a 
<mark class="bg-gray text-white">Termios</mark> struct, we can create a new function called 
<mark class="bg-gray text-white">setTermios</mark>.
</p>
<div class="text-orange mt-4 text-sm">terminal/termios.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">func setTermios(fd uintptr, termios *Termios) error {
    _, _, errno := syscall.Syscall(syscall.SYS_IOCTL, fd, uintptr(syscall.TCSETS+1), uintptr(unsafe.Pointer(termios)))
    if errno != 0 {
        return errno
    }
    
    return nil
}</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<p>
	The main idea is the same as the 
<mark class="bg-gray text-white">getTermios</mark> function, but this time we use 
<mark class="bg-gray text-white">syscall.TCSETS</mark> to set the terminal attributes. We add one to the constant to indicate that we want to change the terminal settings.
</p>
<h3 class="text-xl mt-8 text-green" id="terminal-object">
	Terminal Object
</h3>
<p>
	Now that we have the functions to get and set the terminal attributes, we can create a new struct called 
<mark class="bg-gray text-white">Terminal</mark> that will store all of our terminal-related data. This struct will contain:
</p>
<ul class="list-disc list-outside mb-8 pl-4">
	
<li>The file descriptor of the terminal, which is used to identify it.</li>
	
<li>The original terminal attributes, which will be used to restore the terminal to its original state when the program exits.</li>
	
<li>The modified terminal attributes, which will be used to put the terminal in raw mode.</li>
	
<li>The number of columns and rows of the terminal, which will be used to render the game.</li>
</ul>
<div class="text-orange mt-4 text-sm">terminal/terminal.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">package terminal
    
type Terminal struct {
    fd uintptr
    original Termios
    modified *Termios
    NCols int
    NRows int
}</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<p>
	We will also create a new function called 
<mark class="bg-gray text-white">New</mark> that will return a new 
<mark class="bg-gray text-white">Terminal</mark> object.
</p>
<div class="text-orange mt-4 text-sm">terminal/terminal.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">import (
    "os"
)</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<div class="text-orange mt-4 text-sm">terminal/terminal.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">func New() (*Terminal, error) {
    t := &Terminal{}
    
    t.fd = os.Stdout.Fd()
    termios, err := getTermios(t.fd)
    if err != nil {
        return nil, err
    }
      
    t.original = *termios
    t.modified = termios
    
    return t, nil
}</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<p>
	This function initializes a new 
<mark class="bg-gray text-white">Terminal</mark> object and sets the file descriptor to the standard output. It then gets the current terminal attributes and stores them in the 
<mark class="bg-gray text-white">original</mark> and 
<mark class="bg-gray text-white">modified</mark> attributes. If an error occurs, the function returns 
<mark class="bg-gray text-white">nil</mark> and the error.
</p>
<p>
	We can then create a new method called 
<mark class="bg-gray text-white">Restore</mark> that will restore the terminal to its original state.
</p>
<div class="text-orange mt-4 text-sm">terminal/terminal.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">func (t *Terminal) Restore() error {
    return setTermios(t.fd, &t.original)
}</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<p>
	This method calls the 
<mark class="bg-gray text-white">setTermios</mark> function with the file descriptor and the original terminal attributes. If an error occurs, the method returns the error.
</p>
<h3 class="text-xl mt-8 text-green" id="window-size-and-raw-mode">
	Window Size and Raw Mode
</h3>
<p>
	We will also create a new method called 
<mark class="bg-gray text-white">getWindowSize</mark> that will get the number of columns and rows of the terminal. First, we need to import again the 
<mark class="bg-gray text-white">syscall</mark> and 
<mark class="bg-gray text-white">unsafe</mark> packages, as we will also make a system call to 
<mark class="bg-gray text-white">ioctl</mark> to get the window size.
</p>
<div class="text-orange mt-4 text-sm">terminal/terminal.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">import (
    "os"
    "syscall"
    "unsafe"
)</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<div class="text-orange mt-4 text-sm">terminal/terminal.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">func (t *Terminal) getWindowSize() error {
    ws := struct { 
        row uint16
        col uint16
    }{}
    
    _, _, errno := syscall.Syscall(syscall.SYS_IOCTL, t.fd, syscall.TIOCGWINSZ, uintptr(unsafe.Pointer(&ws)))
    if errno != 0 {
        return errno
    }
    
    t.NCols = int(ws.col)
    t.NRows = int(ws.row)
    
    return nil
}</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<p>
	In this function, we create an anonymous struct called 
<mark class="bg-gray text-white">ws</mark> that contains two fields: 
<mark class="bg-gray text-white">row</mark> and 
<mark class="bg-gray text-white">col</mark>. We then use the 
<mark class="bg-gray text-white">syscall.Syscall</mark> function to make a system call to 
<mark class="bg-gray text-white">ioctl</mark> with 
<mark class="bg-gray text-white">syscall.TIOCGWINSZ</mark> indicating that the window size is to be read. The memory address of the 
<mark class="bg-gray text-white">ws</mark> struct is passed to 
<mark class="bg-gray text-white">ioctl</mark> through 
<mark class="bg-gray text-white">unsafe.Pointer</mark>. If the operation is successful, the function returns the number of columns and rows of the terminal. If there's an error (indicated by a non-zero 
<mark class="bg-gray text-white">errno</mark>), an error is returned instead.
</p>
<p>
	Finally, we will create a new method called 
<mark class="bg-gray text-white">enableRawMode</mark> that will put the terminal in raw mode.
</p>
<div class="text-orange mt-4 text-sm">terminal/terminal.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">func (t *Terminal) enableRawMode() {
    t.modified.Lflag &^= syscall.ECHO | syscall.ICANON | syscall.ISIG | syscall.IEXTEN
    t.modified.Iflag &^= syscall.BRKINT | syscall.ICRNL | syscall.INPCK | syscall.ISTRIP | syscall.IXON
    t.modified.Cflag |= syscall.CS8
    t.modified.Oflag &^= syscall.OPOST
    t.modified.Cc[syscall.VMIN+1] = 0
    t.modified.Cc[syscall.VTIME+1] = 1
}</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<p>
	This method modifies the terminal attributes to put the terminal in raw mode. It turns off a bunch of flags that are enabled by default in our terminal. Basically,
it turns off the echoing of input, canonical mode, and signals. It also sets the character size to 8 bits and turns off output processing. Finally, it sets the minimum number of characters to read before returning from a read and the maximum amount of time to wait before returning from a read.
</p>
<p>
	If you are interested in learning more about the terminal attributes, you can check the 
<a href="https://viewsourcecode.org/snaptoken/kilo/02.enteringRawMode.html">kilo tutorial</a>, which explains in great detail how to put the terminal in raw mode.
</p>
<p>
	Now, we can complete the 
<mark class="bg-gray text-white">New</mark> function by calling the 
<mark class="bg-gray text-white">enableRawMode</mark> and 
<mark class="bg-gray text-white">getWindowSize</mark> methods.
</p>
<div class="text-orange mt-4 text-sm">terminal/terminal.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">func New() (*Terminal, error) {
    t := &Terminal{}
    
    t.fd = os.Stdout.Fd()
    termios, err := getTermios(t.fd)
    if err != nil {
        return nil, err
    }
    
    t.original = *termios
    t.modified = termios
    
    t.enableRawMode()
    err = t.getWindowSize()
    if err != nil {
        return nil, err
    }
    
    err = setTermios(t.fd, t.modified)
    if err != nil {
        return nil, err
    }
    
    return t, nil
}</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<h3 class="text-xl mt-8 text-green" id="main-function">
	Main Function
</h3>
<p>
	Now that we have our terminal object, let's modify the main function to use it. We will create a new terminal object and defer a call to its 
<mark class="bg-gray text-white">Restore</mark> method to ensure that the terminal is restored to its original state when the program exits. Additionally, we will add a loop that reads a single byte from the standard input and exits when the user presses the 
<mark class="bg-gray text-white">q</mark> key.
</p>
<div class="text-orange mt-4 text-sm">main.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">package main
    
import (
    "os"
    "snake/terminal"
)
    
func main() {
    t, err := terminal.New()
    if err != nil {
        panic(err)
    }
    defer t.Restore()
    
    buffer := make([]byte, 1)
    for {
        os.Stdin.Read(buffer) 
    
        if buffer[0] == 'q' {
            break
        }
    }
}</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<p>
	When you run the program, you should see that the terminal is now in raw mode, meaning that the input is processed as soon as the user presses a key. For now, nothing will happen when you press a key, but we will use this functionality to move the snake in the following sections.
</p>
<p>
	When you press the 
<mark class="bg-gray text-white">q</mark> key, the program will exit and the terminal will be restored to its original state.
</p>
<h2 class="text-2xl mt-16 mb-4 text-red font-bold" id="keyboard-input">
	Keyboard Input
</h2>
<p>
	We will create a new module named 
<mark class="bg-gray text-white">inputreader</mark> which will be responsible for reading the user's input and sending the corresponding key to the game loop. 
</p>
<h3 class="text-xl mt-8 text-green" id="inputreader-object">
	InputReader Object
</h3>
<p>
	This module will contain a struct called 
<mark class="bg-gray text-white">InputReader</mark> that will store a buffer to read the user's input.
</p>
<div class="text-orange mt-4 text-sm">inputreader/inputreader.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">package inputreader
    
type InputReader struct {
    buffer []byte
}</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<p>
	We create a new function called 
<mark class="bg-gray text-white">New</mark> that will return a new 
<mark class="bg-gray text-white">InputReader</mark> object.
</p>
<div class="text-orange mt-4 text-sm">inputreader/inputreader.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">func New() *InputReader {
    return &InputReader{buffer: make([]byte, 1)}
}</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<p>
	The buffer will be used to store a single byte of the user's input.
</p>
<p>
	We also create a new method called 
<mark class="bg-gray text-white">Read</mark> that will read the byte from the standard input and return it.
</p>
<div class="text-orange mt-4 text-sm">inputreader/inputreader.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">import (
    "os"
)</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<div class="text-orange mt-4 text-sm">inputreader/inputreader.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">func (ir *InputReader) Read() byte {
    os.Stdin.Read(ir.buffer)
    return ir.buffer[0]
}</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<p>
	It's always important to catch errors when reading from the standard input, but for this application, we don't want the program to panic if an error occurs. Instead, we will ignore the error so the game can continue running.
</p>
<p>
	Now, let's update the main function to use the 
<mark class="bg-gray text-white">InputReader</mark> object.
</p>
<div class="text-orange mt-4 text-sm">main.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">import (
    "snake/terminal"
    "snake/inputreader"
)</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<div class="text-orange mt-4 text-sm">main.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">func main() {
    t, err := terminal.New()
    
    if err != nil {
        panic(err)
    }
    defer t.Restore()
    
    ir := inputreader.New()
    
    for {
        key := ir.Read()
    
        if key == 'q' {
            break
        }
    }
}</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<p>
	If you run the program now, you should see that the terminal is still in raw mode and that the program exits when you press the 
<mark class="bg-gray text-white">q</mark> key.
</p>
<h3 class="text-xl mt-8 text-green" id="reading-arrow-keys">
	Reading Arrow Keys
</h3>
<p>
	Arrow keys are a bit special, as they are represented by three bytes instead of one:
</p>
<ul class="list-disc list-outside mb-8 pl-4">
	
<li>Up: 
<mark class="bg-gray text-white">27 91 65</mark></li>
	
<li>Down: 
<mark class="bg-gray text-white">27 91 66</mark></li>
	
<li>Right: 
<mark class="bg-gray text-white">27 91 67</mark></li>
	
<li>Left: 
<mark class="bg-gray text-white">27 91 68</mark></li>
</ul>
<p>
	We will update the 
<mark class="bg-gray text-white">Read</mark> method to detect arrow keys and map them to a single byte, corresponding with the WASD keys.
</p>
<div class="text-orange mt-4 text-sm">inputreader/inputreader.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">func (ir *InputReader) Read() byte {
    os.Stdin.Read(ir.buffer)
    
    if ir.buffer[0] == 27 {
        seq := make([]byte, 2)
        os.Stdin.Read(seq)
        if seq[0] == 91 {
            switch seq[1] {
            case 65:
                return 'w'
            case 66:
                return 's'
            case 67:
                return 'd'
            case 68:
                return 'a'
            }
        }
    }
    
    return ir.buffer[0]
}</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<p>
	With this, we have finished with the user's input for a long time. We will now move on to the game loop and rendering.
</p>
<h2 class="text-2xl mt-16 mb-4 text-red font-bold" id="game-loop-and-rendering">
	Game Loop and Rendering
</h2>
<p>
	Once we have the user's input, we can start working on the game loop. The game loop will be responsible for updating the game state. For now, we will use the cursor as the object we want to move around the terminal. Then, it will be easy to replace the cursor with the snake.
</p>
<h3 class="text-xl mt-8 text-green" id="game-loop">
	Game Loop
</h3>
<p>
	Let's create a struct called 
<mark class="bg-gray text-white">Game</mark> that will store the cursor position, and the respective 
<mark class="bg-gray text-white">New</mark> function.
</p>
<div class="text-orange mt-4 text-sm">game/game.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">package game
    
type Game struct {
    X int
    Y int
}
    
func New() *Game {
    return &Game{X: 0, Y: 0}
}</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<p>
	Now, we can create a new method called 
<mark class="bg-gray text-white">Update</mark> that will update the game state based on the user's input.
</p>
<div class="text-orange mt-4 text-sm">game/game.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">func (g *Game) Update(key byte) {
    switch key {
    case 'w':
        g.Y--
    case 's':
        g.Y++
    case 'a':
        g.X--
    case 'd':
        g.X++
    }
}</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<p>
	With all this, we can update the main function to use the 
<mark class="bg-gray text-white">Game</mark> object and update the game state based on the user's input.
</p>
<div class="text-orange mt-4 text-sm">main.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">func main() {
    t, err := terminal.New()
    
    if err != nil {
        panic(err)
    }
    defer t.Restore()
    
    ir := inputreader.New()
    
    g := game.New()
    
    for {
        key := ir.Read()
        if key == 'q' {
            break
        }
    
        g.Update(key)
    }
}</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<p>
	If you run the program, nothing should have changed.
</p>
<h3 class="text-xl mt-8 text-green" id="rendering">
	Rendering
</h3>
<p>
	Now that we have the game state, we can start rendering the game. We will create a new module called 
<mark class="bg-gray text-white">renderer</mark> that will be responsible for rendering the game state to the terminal.
</p>
<p>
	Inside the renderer module, we will create a new struct called 
<mark class="bg-gray text-white">Renderer</mark> and a new function called 
<mark class="bg-gray text-white">New</mark> that will return a new 
<mark class="bg-gray text-white">Renderer</mark> object.
</p>
<div class="text-orange mt-4 text-sm">renderer/renderer.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">package renderer
    
type Renderer struct {
}
    
func New() *Renderer {
    return &Renderer{}
}</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<p>
	We will also create a new method called 
<mark class="bg-gray text-white">Render</mark> that will render the game state to the terminal.
</p>
<div class="text-orange mt-4 text-sm">renderer/renderer.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">import (
    "fmt"
    "os"
    "snake/game"
)</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<div class="text-orange mt-4 text-sm">renderer/renderer.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">func (r *Renderer) Render(g *game.Game) {
    cursorPos := fmt.Sprintf("\x1b[%d;%dH", g.Y+1, g.X+1)
    os.Stdout.WriteString(cursorPos)
}</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<p>
	This method uses the 
<mark class="bg-gray text-white">fmt.Sprintf</mark> function to create a string with the escape sequence 
<mark class="bg-gray text-white">ESC[n;mH</mark>, where 
<mark class="bg-gray text-white">n</mark> and 
<mark class="bg-gray text-white">m</mark> are the row and column of the cursor, respectively. The string is then written to the standard output, a.k.a, the terminal GUI.
</p>
<p>
	Now, we can update the main function to use the 
<mark class="bg-gray text-white">Renderer</mark> object and render the game state.
</p>
<div class="text-orange mt-4 text-sm">main.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">import (
    "snake/terminal"
    "snake/inputreader"
    "snake/game"
    "snake/renderer"
)</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<div class="text-orange mt-4 text-sm">main.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">func main() {
    t, err := terminal.New()
    
    if err != nil {
        panic(err)
    }
    defer t.Restore()
    
    ir := inputreader.New()
    g := game.New()
    r := renderer.New()
    
    for {
        key := ir.Read()
        if key == 'q' {
            break
        }
    
        g.Update(key)
    
        r.Render(g)
    }
}</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<p>
	If you run your program, you will be able to move the cursor around the terminal using the WASD and arrow keys. However, you can notice several issues:
</p>
<ul class="list-disc list-outside mb-8 pl-4">
	
<li>The cursor can go out of the terminal's boundaries, printing weird stuff.</li>
	
<li>When you exit the program, the cursor doesn't return to its original position.</li>
	
<li>The cursor doesn't move smoothly.</li>
</ul>
<p>
	Let's solve these issues one by one.
</p>
<h3 class="text-xl mt-8 text-green" id="clamping-the-cursor-position">
	Clamping the Cursor Position
</h3>
<p>
	This is the easiest issue to solve. In the 
<mark class="bg-gray text-white">Update</mark> method of the 
<mark class="bg-gray text-white">Game</mark> object, we can clamp the cursor position to the terminal's boundaries. For this, we will need to tell the game object the size of the terminal, or board, in this case. That information is stored
in the 
<mark class="bg-gray text-white">Terminal</mark> object. So, let's add two new attributes to the 
<mark class="bg-gray text-white">Game</mark> object and update the 
<mark class="bg-gray text-white">New</mark> function to accept the number of columns and rows of the terminal.
</p>
<div class="text-orange mt-4 text-sm">game/game.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">type Game struct {
    X int
    Y int
    NRows int
    NCols int
}
    
func New(nRows, nCols int) *Game {
    return &Game{X: 0, Y: 0, NRows: nRows, NCols: nCols}
}</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<p>
	In the main function, we can update the 
<mark class="bg-gray text-white">New</mark> function call to pass the number of columns and rows of the terminal.
</p>
<div class="text-orange mt-4 text-sm">main.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">    g := game.New(t.NRows, t.NCols)</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<p>
	Now, we can update the 
<mark class="bg-gray text-white">Update</mark> method to clamp the cursor position to the terminal's boundaries.
</p>
<div class="text-orange mt-4 text-sm">game/game.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">func (g *Game) Update(key byte) {
    switch key {
    case 'w':
        if g.Y &gt; 0 {
            g.Y--
        }
    case 's':
        if g.Y &lt; g.NRows-1 {
            g.Y++
        }
    case 'a':
        if g.X &gt; 0 {
            g.X--
        }
    case 'd':
        if g.X &lt; g.NCols-1 {
            g.X++
        }
    }
}</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<p>
	If you run the program now, you should see that the cursor is clamped to the terminal's boundaries.
</p>
<h3 class="text-xl mt-8 text-green" id="restoring-the-cursor-position">
	Restoring the Cursor Position
</h3>
<p>
	This issue is caused by the fact that we are not restoring the cursor position when the program exits. We can solve this issue by adding a new method to the 
<mark class="bg-gray text-white">Renderer</mark> object that will restore the cursor position to its original state.
</p>
<p>
	To restore the terminal correctly, we will need to add the following escape sequences by order:
</p>
<ul class="list-disc list-outside mb-8 pl-4">
	
<li>To hide the cursor: 
<mark class="bg-gray text-white">ESC[?25l</mark></li>
	
<li>To move the cursor to the top-left corner: 
<mark class="bg-gray text-white">ESC[H</mark></li>
	
<li>To clear the terminal screen: 
<mark class="bg-gray text-white">ESC[2J</mark></li>
	
<li>To show the cursor: 
<mark class="bg-gray text-white">ESC[?25h</mark></li>
</ul>
<p>
	Let's create all these constants in the 
<mark class="bg-gray text-white">renderer</mark> module.
</p>
<div class="text-orange mt-4 text-sm">renderer/renderer.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">const (
    clearScreen = "\x1b[2J"
    cursorHide = "\x1b[?25l"
    cursorShow = "\x1b[?25h"
    cursorHome = "\x1b[H"
)</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<p>
	Now, we can create a new method called 
<mark class="bg-gray text-white">Restore</mark> that will restore the cursor position to its original state.
</p>
<div class="text-orange mt-4 text-sm">renderer/renderer.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">func (r *Renderer) Restore() {
    outString := cursorHide
    outString += clearScreen
    outString += cursorHome
    outString += cursorShow
    os.Stdout.WriteString(outString)
}</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<p>
	Let's change the main function to call all the 
<mark class="bg-gray text-white">Restore</mark> methods when the program exits. For that, we will create a new function called 
<mark class="bg-gray text-white">atExit</mark> that will be called when the program exits.
</p>
<div class="text-orange mt-4 text-sm">main.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">func atExit(t *terminal.Terminal, r *renderer.Renderer) {
    t.Restore()
    r.Restore()
}</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<div class="text-orange mt-4 text-sm">main.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">func main() {
    t, err := terminal.New()
    if err != nil {
        panic(err)
    }
    
    ir := inputreader.New()
    g := game.New(t.NRows, t.NCols)
    r := renderer.New()
    
    defer atExit(t, r)
    for {
        key := ir.Read()
        if key == 'q' {
            break
        }
    
        g.Update(key)
        r.Render(g)
    }
}</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<p>
	The program should now restore the cursor position when it exits.
</p>
<h3 class="text-xl mt-8 text-green" id="moving-the-cursor-smoothly">
	Moving the Cursor Smoothly
</h3>
<p>
	The last issue is caused by the fact that we are rendering the game continuously. We can solve this issue by adding a game tick to the game loop. A game tick is a fundamental concept that allows you to control the flow and timing of game processes, ensuring that movement and other game mechanics are executed at a consistent rate, independent of the system's processing speed.
</p>
<p>
	This can be achieved by using a 
<mark class="bg-gray text-white">time.Ticker</mark> from the 
<mark class="bg-gray text-white">time</mark> package. A ticker can be set to emit events at a fixed interval, which you can use to update game states such as cursor movement, input handling, and rendering. 
</p>
<div class="text-orange mt-4 text-sm">main.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">import (
    "time"
    "snake/terminal"
    "snake/inputreader"
    "snake/game"
    "snake/renderer"
)</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<p>
	Let's add the tick rate and the ticker to the main function.
</p>
<div class="text-orange mt-4 text-sm">main.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">    tickRate := time.Second / 10
    ticker := time.NewTicker(tickRate)</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<p>
	And update the 
<mark class="bg-gray text-white">atExit</mark> function to stop the ticker when the program exits.
</p>
<div class="text-orange mt-4 text-sm">main.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">func atExit(t *terminal.Terminal, r *renderer.Renderer, ticker *time.Ticker) {
    t.Restore()
    r.Restore()
    ticker.Stop()
}</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<p>
	Now, we can update the game loop to use the ticker.
</p>
<div class="text-orange mt-4 text-sm">main.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">    defer atExit(t, r, ticker)
    for {
        select {
        case &lt;-ticker.C:
            key := ir.Read()
            if key == 'q' {
                return
            }
    
            g.Update(key)
            r.Render(g)
        }
    }</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<p>
	Note that the 
<mark class="bg-gray text-white">break</mark> when the 
<mark class="bg-gray text-white">q</mark> key is pressed was replaced by a 
<mark class="bg-gray text-white">return</mark> statement. This is because we are using a 
<mark class="bg-gray text-white">select</mark> statement, which is used to wait for multiple channel operations. In this case, we are waiting for the ticker to emit an event.
</p>
<h3 class="text-xl mt-8 text-green" id="non-blocking-input">
	Non-blocking Input
</h3>
<p>
	We haven't still solved the issue of smooth movement. The problem is that, as we have the code now, the input of the user is read only when the ticker emits an event. This means that the user's input is only processed at a fixed interval, which is not what we want. We want the user's input to be processed as soon as it is received.
</p>
<p>
	In Go, we can achieve this by using goroutines and channels. Goroutines are lightweight threads managed by the Go runtime, and channels are Go's way of allowing goroutines to communicate with each other safely.
</p>
<p>
	The first thing we need to do is to update the 
<mark class="bg-gray text-white">Read</mark> method of the 
<mark class="bg-gray text-white">InputReader</mark> object to use and store the input in a channel.
</p>
<div class="text-orange mt-4 text-sm">inputreader/inputreader.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">func (ir *InputReader) Read(events chan byte) {
    for {
        for {
            readLen, _ := os.Stdin.Read(ir.buffer)
            if readLen &gt; 0 {
                break
            }
        }
        if ir.buffer[0] == 27 {
            seq := make([]byte, 2)
            os.Stdin.Read(seq)
            if seq[0] == 91 {
                switch seq[1] {
                case 65:
                    events &lt;- 'w'
                    continue
                case 66:
                    events &lt;- 's'
                    continue
                case 67:
                    events &lt;- 'd'
                    continue
                case 68:
                    events &lt;- 'a'
                    continue
                }
            }
        }
        events &lt;- ir.buffer[0]
    }
}</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<p>
	Note that we have made several key changes to the method:
</p>
<ul class="list-disc list-outside mb-8 pl-4">
	
<li>First, we have added a new argument called 
<mark class="bg-gray text-white">events</mark> of type 
<mark class="bg-gray text-white">chan byte</mark>. This is the channel that will be used to communicate with the main goroutine.</li>
	
<li>We have removed the output of the method, as it is no longer needed.</li>
	
<li>Now the method is an infinite loop that reads the user's input and sends it to the 
<mark class="bg-gray text-white">events</mark> channel.</li>
	
<li>There is a second loop that reads the user's input until it receives a byte.</li>
	
<li>In the switch statement, we have replaced the 
<mark class="bg-gray text-white">return</mark> statement with a two new statements: adding the key to the 
<mark class="bg-gray text-white">events</mark> channel and a 
<mark class="bg-gray text-white">continue</mark> statement.</li>
</ul>
<p>
	Now, in the main function, we can create a new channel and start a new goroutine to read the user's input. Additionally, we create a new variable called 
<mark class="bg-gray text-white">input</mark> to store the user's input.
</p>
<div class="text-orange mt-4 text-sm">main.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">    events := make(chan byte)
    go ir.Read(events)
    var input byte</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<p>
	And we update the main loop.
</p>
<div class="text-orange mt-4 text-sm">main.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">    for {
        select {
        case &lt;-ticker.C:
            r.Render(g)
            g.Update(input)
        case input = &lt;-events:
            if input == 'q' {
                return
            }
        }
    }</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<p>
	If you run the game, you should see that the cursor moves smoothly and that the user's input is processed as soon as it is received. 
</p>
<p>
	You should also see that the cursor moves continuously, even if the user doesn't press any key. This is because the pressed key is stored in the 
<mark class="bg-gray text-white">input</mark> variable and used in the next iteration of the game loop. However, if you press any other key, the cursor will stop, as in the switch statement of the 
<mark class="bg-gray text-white">Update</mark> method of the 
<mark class="bg-gray text-white">Game</mark> object, there is no case for that key. We will fix that soon.
</p>
<h2 class="text-2xl mt-16 mb-4 text-red font-bold" id="the-snake">
	The Snake
</h2>
<p>
	It's time we add the snake to the game. The snake will be represented by a list of coordinates, and it will move continuously in the direction of the last key pressed. When the snake eats the food, it will grow by one unit. If the snake collides with the boundaries of the terminal or with itself, the game will end.
</p>
<h3 class="text-xl mt-8 text-green" id="snake-object">
	Snake Object
</h3>
<p>
	Let's create a new file called 
<mark class="bg-gray text-white">snake.go</mark> inside the 
<mark class="bg-gray text-white">game</mark> module and add a new struct called 
<mark class="bg-gray text-white">Snake</mark> to it.
</p>
<div class="text-orange mt-4 text-sm">game/snake.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">package game
    
type Snake struct {
    Body []Point
    Dir  Direction
}</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>    
<p>
	Now, let's define the 
<mark class="bg-gray text-white">Point</mark> and 
<mark class="bg-gray text-white">Direction</mark> types in the 
<mark class="bg-gray text-white">game.go</mark> file.
</p>
<div class="text-orange mt-4 text-sm">game/game.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">type Point struct {
    X int
    Y int
}</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<div class="text-orange mt-4 text-sm">game/game.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">type Direction int 
const (
    Up Direction = iota
    Down
    Left
    Right
)</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<p>
	Let's create a function to create a new snake.
</p>
<div class="text-orange mt-4 text-sm">game/snake.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">func NewSnake() *Snake {
    head := Point{1, 0}
    body := Point{0, 0}
    
    return &Snake{
        Body: []Point{body, head},
        Dir:  Right,
    }
}</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<p>
	We initialize the snake to be two units long, with the head at the position 
<mark class="bg-gray text-white">(1, 0)</mark> and the body at the position 
<mark class="bg-gray text-white">(0, 0)</mark>. The direction of the snake is set to 
<mark class="bg-gray text-white">Right</mark>.
</p>
<p>
	And finally, let's update the 
<mark class="bg-gray text-white">Game</mark> object to store the snake, and remove the 
<mark class="bg-gray text-white">X</mark> and 
<mark class="bg-gray text-white">Y</mark> attributes, as they are no longer needed.
</p>
<div class="text-orange mt-4 text-sm">game/game.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">type Game struct {
    NRows int
    NCols int
    Snake *Snake
}</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<div class="text-orange mt-4 text-sm">game/game.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">func New(nRows, nCols int) *Game {
    return &Game{
        NRows: nRows,
        NCols: nCols,
        Snake: NewSnake(),
    }
}</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<h3 class="text-xl mt-8 text-green" id="moving-the-snake">
	Moving the Snake
</h3>
<p>
	We will handle the movement of the snake in a new method called 
<mark class="bg-gray text-white">Move</mark> of the 
<mark class="bg-gray text-white">Snake</mark> object.
</p>
<div class="text-orange mt-4 text-sm">game/snake.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">func (s *Snake) Move() {
    head := s.Body[len(s.Body)-1]
    var newHead Point
    switch s.Dir {
    case Up:
        newHead = Point{head.X, head.Y - 1}
    case Down:
        newHead = Point{head.X, head.Y + 1}
    case Left:
        newHead = Point{head.X - 1, head.Y}
    case Right:
        newHead = Point{head.X + 1, head.Y}
    }
    s.Body = append(s.Body, newHead)
}</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<p>
	And in the 
<mark class="bg-gray text-white">Game</mark> object, we will update the 
<mark class="bg-gray text-white">Update</mark> method to move the snake in the direction of the last key pressed.
</p>
<div class="text-orange mt-4 text-sm">game/game.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">func (g *Game) Update(key byte) {
    switch key {
    case 'w':
        g.Snake.Dir = Up
    case 's':
        g.Snake.Dir = Down
    case 'a':
        g.Snake.Dir = Left
    case 'd':
        g.Snake.Dir = Right
    }
    g.Snake.Move()
}</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<p>
	With this, the snake will only grow on every iteration of the game loop. We will fix by adding a new method called 
<mark class="bg-gray text-white">Pop</mark> to the 
<mark class="bg-gray text-white">Snake</mark> object. This method will remove the first element of the snake's body, effectively making it move.
</p>
<div class="text-orange mt-4 text-sm">game/snake.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">func (s *Snake) Pop() {
    s.Body = s.Body[1:]
}</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<p>
	And we will update the 
<mark class="bg-gray text-white">Update</mark> method of the 
<mark class="bg-gray text-white">Game</mark> object to call the 
<mark class="bg-gray text-white">Pop</mark> method after the snake moves.
</p>
<div class="text-orange mt-4 text-sm">game/game.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">func (g *Game) Update(key byte) {
    switch key {
    case 'w':
        g.Snake.Dir = Up
    case 's':
        g.Snake.Dir = Down
    case 'a':
        g.Snake.Dir = Left
    case 'd':
        g.Snake.Dir = Right
    }
    g.Snake.Move()
    g.Snake.Pop()
}</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<p>
	Now, the snake will move continuously in the direction of the last key pressed.
</p>
<h3 class="text-xl mt-8 text-green" id="rendering-the-snake">
	Rendering the Snake
</h3>
<p>
	We need to update the 
<mark class="bg-gray text-white">Render</mark> method of the 
<mark class="bg-gray text-white">Renderer</mark> object to render the snake to the terminal, instead of the cursor.
</p>
<div class="text-orange mt-4 text-sm">renderer/renderer.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">func (r *Renderer) Render(g *game.Game) {
    strOut := clearScreen
    for i, p := range g.Snake.Body {
        if len(g.Snake.Body) - 1 == i {
            strOut += fmt.Sprintf("\x1b[%d;%dHO", p.Y+1, p.X+1)
            break
        }
        strOut += fmt.Sprintf("\x1b[%d;%dH@", p.Y+1, p.X+1)
    }
    strOut += cursorHide
    os.Stdout.WriteString(strOut)
}</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<p>
	As we did previously with the cursor, we are using the escape sequence 
<mark class="bg-gray text-white">ESC[y;xH</mark> to move the cursor to the position 
<mark class="bg-gray text-white">(x, y)</mark>. We are adding a 
<mark class="bg-gray text-white">@</mark> character to the position of the snake's body, and a 
<mark class="bg-gray text-white">O</mark> character to the position of the snake's head.
</p>
<p>
	Remember that the terminal is one-indexed, so we need to add 1 to the position of the snake's body and head.
</p>
<p>
	Now, if you run the game, you should be able to control the snake.
</p>
<h2 class="text-2xl mt-16 mb-4 text-red font-bold" id="food-and-game-over">
	Food and Game Over
</h2>
<p>
	The last thing we need to do is to add the food to the game and handle the game over condition.
</p>
<h3 class="text-xl mt-8 text-green" id="food-object">
	Food Object
</h3>
<p>
	The food object will be represented by a single point, so we can reuse the 
<mark class="bg-gray text-white">Point</mark> type we created previously.
</p>
<div class="text-orange mt-4 text-sm">game/game.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">type Game struct {
    NRows int
    NCols int
    Snake *Snake
    Food Point
}</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<p>
	For placing the food, we will create a new method called 
<mark class="bg-gray text-white">spawnFood</mark> of the 
<mark class="bg-gray text-white">Game</mark> object. This method will generate a random position for the food and check if the position is not occupied by the snake. Let's import the 
<mark class="bg-gray text-white">math/rand</mark> module.
</p>
<div class="text-orange mt-4 text-sm">game/game.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">import (
    "math/rand"
)</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<div class="text-orange mt-4 text-sm">game/game.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">func (g *Game) spawnFood() {
    x := rand.Intn(g.NCols)
    y := rand.Intn(g.NRows)
    
    g.Food = Point{x, y}
    
    for _, p := range g.Snake.Body {
        if p == g.Food {
            g.spawnFood()
        }
    }
}</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<p>
	Note the beauty of recursion. If the food is placed in the same position as the snake, we call the 
<mark class="bg-gray text-white">spawnFood</mark> method again.
</p>
<p>
	As the 
<mark class="bg-gray text-white">spawnFood</mark> method needs to know where the snake is, we will need to restructure the 
<mark class="bg-gray text-white">New</mark> function to call the 
<mark class="bg-gray text-white">spawnFood</mark> method after the snake is created.
</p>
<div class="text-orange mt-4 text-sm">game/game.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">func New(nRows, nCols int) *Game {
    g := &Game{NRows: nRows, NCols: nCols}
    g.Snake = NewSnake()
    g.spawnFood()
    
    return g
}</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<p>
	Lastly, we just simply update the condition of the 
<mark class="bg-gray text-white">Update</mark> function to check if the snake's head is in the same position as the food, right after the snake moves.
</p>
<div class="text-orange mt-4 text-sm">game/game.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">    head := g.Snake.Body[len(g.Snake.Body)-1]
    if head == g.Food {
        g.spawnFood()
    } else {
        g.Snake.Pop()
    }</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<p>
	If the snake's head is in the same position as the food, we call the 
<mark class="bg-gray text-white">spawnFood</mark> method again. Otherwise, we call the 
<mark class="bg-gray text-white">Pop</mark> method. This way, the snake will grow when it eats the food, as the 
<mark class="bg-gray text-white">Pop</mark> method is not called.
</p>
<p>
	And we can render the food to the terminal adding the following line right after the snake is rendered.
</p>
<div class="text-orange mt-4 text-sm">game/game.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">    strOut += fmt.Sprintf("\x1b[%d;%dH*", g.Food.Y+1, g.Food.X+1)</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<p>
	Now, if you run the game, you should be able to control the snake and eat the food.
</p>
<h3 class="text-xl mt-8 text-green" id="game-over">
	Game Over
</h3>
<p>
	The game over condition is simple. If the snake collides with the boundaries of the terminal or with itself, the game is over.
</p>
<div class="text-orange mt-4 text-sm">game/game.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">func (g *Game) GameOver() bool {
    head := g.Snake.Body[len(g.Snake.Body)-1]
    if head.X &lt; 0 || head.X &gt; g.NCols || head.Y &lt; 0 || head.Y &gt; g.NRows {
        return true
    }
    
    for i, p := range g.Snake.Body {
        if i == len(g.Snake.Body)-1 {
            continue
        }
        if p == head {
            return true
        }
    }
    
    return false
}</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<p>
	And we will update the main loop to check if the game is over.
</p>
<div class="text-orange mt-4 text-sm">main.go</div>
    
<div class="relative">
        
<pre class="border border-white overflow-x-auto p-4 mb-8">
<code class="!bg-black !text-sm language-go">    for {
        select {
        case &lt;-ticker.C:
            r.Render(g)
            g.Update(input)
            if g.GameOver() {
                return
            }
        case input = &lt;-events:
            if input == 'q' {
                return
            }
        }
    }</code></pre>
        
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
    </div>
<p>
	Now, if you run the game, you should see that the game is over when the snake collides with the boundaries of the terminal or with itself. This, effectively, concludes our game.
</p>
<h2 class="text-2xl mt-16 mb-4 text-red font-bold" id="wrapping-up">
	Wrapping Up
</h2>
<p>
	In this tutorial, we have created a simple snake game using the terminal. We have learned how to store and restore the terminal attributes, read the user's input, move the cursor, and render the game state to the terminal. We have also learned how to use goroutines and channels to handle non-blocking input, and how to use a game tick to control the flow and timing of game processes.
</p>
<p>
	I suggest you continue to improve the game by adding more features, such as:
</p>
<ul class="list-disc list-outside mb-8 pl-4">
	
<li>A score and high score system.</li>
	
<li>A game over, start, and pause screens.</li>
	
<li>A speed increase when the snake eats the food.</li>
</ul>
<p>
	I hope you have learned how versatile the terminal can be and how easy it is to create a simple game using it. I encourage you to experiment and see if you can create more complex games.
</p>
<div style="height: 120px;"></div>
    
<div class="absolute left-0 right-0 h-2 bg-orange"></div>
    
<script src="/js/copyCode.js"></script>
    
<script> hljs.highlightAll(); </script>
</body>
</html>
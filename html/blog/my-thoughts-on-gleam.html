<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="/css/output.css">
<link id="highlight-style" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.0/styles/atom-one-dark.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.0/highlight.min.js"></script>

<header>
<nav class="flex justify-evenly max-w-4xl mx-auto p-4">
<a class="text-lg font-semibold text-white no-underline" href="/">about</a>
<a class="text-lg font-semibold text-white no-underline" href="/projects">projects</a>
<a class="text-lg font-semibold text-white no-underline" href="/research">research</a>
<a class="text-lg font-semibold text-white no-underline" href="/tutorials">tutorials</a>
<a class="text-lg font-semibold text-white no-underline" href="/blog">blog</a>
</nav>
</header>

<div class="max-w-4xl mx-auto px-8">

<h1 class="text-3xl font-bold mt-8 mb-4 text-center text-violet" id="my-thoughts-on-gleam">My Thoughts on Gleam</h1>

<div class="text-sm text-center mb-16">
<span>published on <mark class="bg-gray text-white">apr 1st 2024
</mark></span>
•
<span>last edited on <mark class="bg-gray text-white">apr 1st 2024
</mark></span>
•
<span><mark class="bg-gray text-white">10
min</mark> read</span>
</div>

I have recently completed a good amount of the <a href="https://adventofcode.com/2020">Advent of Code 2020</a> puzzles using <a href="https://gleam.run/">Gleam</a>, a relatively new functional programming language. I have always been so curious of functional languages as I didn't understand by first hand how they worked. I mean, how can't you use for-loops?

Gleam <mark class='bg-gray text-white'>v1.0.0</mark> has been recently released and I had to try it. Something really caught my eye.

This <a href="https://tchojnacki.dev/blog/evaluating-gleam-with-aoc">blog post</a>

<h2 class="text-2xl mt-16 mb-4 text-red font-bold" id="table-of-contents">
Table of Contents
</h2>

<ul class="list-none list-inside mb-8">
<li>-&gt;&nbsp;<a href="#gleam">Gleam</a></li>
<li>-&gt;&nbsp;<a href="#the-good">The Good</a></li>
<li>-&gt;&nbsp;<a href="#the-bad">The Bad</a></li>
<li>-&gt;&nbsp;<a href="#wrapping-up">Wrapping Up</a></li>
<li>-&gt;&nbsp;<a href="#cool-gleam-resources">Cool Gleam Resources</a></li>
</ul>

<h2 class="text-2xl mt-16 mb-4 text-red font-bold" id="gleam">
Gleam
</h2>

Gleam is a very accessible functional type-safe language written in Rust. It can compile its code to Erlang and JavaScript, being able to run on the Erlang Virtual Machin (BEAM) and JavaScript runtimes such as Node or Deno.

Gleam is meant to be very simple and I bet you can learn it in only one afternoon. Moreover, Gleam has a great <a href="https://tour.gleam.run/">language tour</a> to help you learn via the browser.

I have used Gleam enough to have an opinion on the basic functionality of the language. So, here are my thoughts.

<h2 class="text-2xl mt-16 mb-4 text-red font-bold" id="the-good">
The Good
</h2>

<h3 class="text-xl mt-8 text-green" id="philosophy">
Philosophy
</h3>

Gleam looks like it has taken all the best things for many different languages. Go's code simplicity, Rust-like syntax, and Elixir's code flow.

First of all, I want to appreciate Gleam's philosophy on simplicity. I am a big fan of simple and easy-to-read languages, and Gleam will be introducing new features very conservatively. I think it is a great choice as it keeps the language very accessible for beginners and it prevents the language bloat as in C++ or Rust.

<h3 class="text-xl mt-8 text-green" id="tooling">
Tooling
</h3>

Gleam's tooling is very good for being such a young language. It comes with the compiler, the build tool, a package manager, a formatter, and a language server.

Nowadays, for a programming language to succeed, the tooling is as important as the language itself. I have to say that the language server is not still there, but as long as I know, it is one of the top priorities of the Gleam team.

Also, while not super extent, the documentation for the Gleam standard library is very good. As there is not much community as in other language, I found myself consulting the documentation very often. It is very easy to look up functions.

The Gleam CLI is nearly perfect. Using the CLI is so intuitive and it offers all tooling under one single command. As a beginner, it is also a difficult entry point to know the jargon of the tooling. For example, in JavaScript, there are many engines (<mark class='bg-gray text-white'>v8</mark>, <mark class='bg-gray text-white'>JavaScriptCore</mark>...), runtimes (<mark class='bg-gray text-white'>Deno</mark>, <mark class='bg-gray text-white'>Node</mark>, <mark class='bg-gray text-white'>Bun</mark>...), package managers (<mark class='bg-gray text-white'>npm</mark>, <mark class='bg-gray text-white'>yarn</mark>, <mark class='bg-gray text-white'>bun</mark>...), and even version managers for package managers as <mark class='bg-gray text-white'>nvm</mark>!

Another example is Rust, where it is managed by <mark class='bg-gray text-white'>rustup</mark>, the compiler is <mark class='bg-gray text-white'>rustc</mark>; and the package manager, project creation, and runtime, through <mark class='bg-gray text-white'>cargo</mark>.

Gleam takes the best from both the Go and cargo CLIs. Everything is executed via the <mark class='bg-gray text-white'>gleam</mark> command. For project creation, <mark class='bg-gray text-white'>gleam new</mark> creates a new project, <mark class='bg-gray text-white'>gleam run</mark> runs it, and <mark class='bg-gray text-white'>gleam build</mark> builds it. For managing the dependencies, <mark class='bg-gray text-white'>gleam add</mark> adds them, <mark class='bg-gray text-white'>gleam remove</mark> removes them, and <mark class='bg-gray text-white'>gleam update</mark> updates them. It even lets you publish your project directly via <mark class='bg-gray text-white'>gleam publish</mark>. Shouldn't all languages be like this?

<h3 class="text-xl mt-8 text-green" id="standard-library">
Standard library
</h3>

Gleam's standard library is very well designed. Its functional nature lets Gleam to divide the standard library's functions into their primitive types. Everything is just where it should be. It is very inspired from Elixir's standard library, but in my opinion, with a better naming convention and layout.

All types in Gleam are capitalized, while all libraries for the types are in lowercase.

For example, in Elixir, to parse an integer from a string is done with <mark class='bg-gray text-white'>String.to_integer</mark>, and in Gleam with <mark class='bg-gray text-white'>int.parse</mark>. I just think Gleam's way is the one that makes the most sense.

<h3 class="text-xl mt-8 text-green" id="syntax">
Syntax
</h3>

Gleam's syntax is in my opinion the best one I have ever seen. I love all the choices the Gleam team have made, taking the best of multiple languages. I really love the Rust syntax of functions with <mark class='bg-gray text-white'>fn</mark>, the visibility outside the module with <mark class='bg-gray text-white'>pub</mark>, and the function signatures with <mark class='bg-gray text-white'>fn name(arg: Type) -> Type</mark>. I love how accessing module functions is done with dot notation <mark class='bg-gray text-white'>module.function</mark> instead of double colon notation <mark class='bg-gray text-white'>module::function</mark>. I love how Gleam enforces functions and variables to be snake-cased, and types to be camel-cased. I also love in-and-out keywords for function arguments, one of Swift's coolest features.

<h3 class="text-xl mt-8 text-green" id="pipelines">
Pipelines
</h3>

Pipelines are a way of writing clearer code when you have to make function composition. The pipe operator <mark class='bg-gray text-white'>|></mark> takes the result of the expression on its left and passes it as an argument to the function on its right. So, instead of writing code that reads from the inside out, it read from top to bottom.

<div class="relative">
<pre class="border border-white overflow-x-auto px-4 py-2 mb-8 mt-4"><code class="!bg-black !text-sm language-elixir">
// This
io.debug(string.drop_left(string.drop_right("Hello, mom!", 1), 7))

// is equivalent to this
"Hello, mom!"
|&gt;  string.drop_right(1)
|&gt;  string.drop_left(7)
|&gt;  io.debug
</code></pre>
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
<div class="absolute -top-1 left-0 m-2 text-sm text-orange"></div>
</div>

Pipelines are just perfect for functional programming languages at it helps function composition, the main idea behind them. For example, I don't like how getting the length of strings or lists are handled in non-functional programming languages like Go or Python. Instead of being a builtin method of the type, it is a global function called <mark class='bg-gray text-white'>len</mark>. This makes function composition or chaining less readable. This mix between global functions and type methods is confusing sometimes.

Now that I have discovered the existence of pipelines, I will grumble every time I program in another language and see a clear piping moment. Every language should have pipelines.

<h3 class="text-xl mt-8 text-green" id="pattern-matching">
Pattern matching
</h3>

Pattern matching are if-else statements on steroids. 

Why would anyone use <mark class='bg-gray text-white'>if statements</mark>?

Capture

<h2 class="text-2xl mt-16 mb-4 text-red font-bold" id="the-bad">
The Bad
</h2>

<h3 class="text-xl mt-8 text-green" id="no-early-returns">
No early returns
</h3>

I don't mind that there is no explicit return keyword for functions, but the thing is that there is no early return.

<h3 class="text-xl mt-8 text-green" id="unwrap-operator">
Unwrap operator
</h3>

Excessive unwrapping

You can mitigate it my using <mark class='bg-gray text-white'>let assert Ok(ident) = ...</mark>, but using a <mark class='bg-gray text-white'>!</mark> would just be simpler.

<h3 class="text-xl mt-8 text-green" id="some-missing-basic-functions">
Some missing basic functions
</h3>

Reading external files. You can use external dependencies as <a href="https://github.com/lpil/filepath">filepath</a> or <a href="https://github.com/bcpeinhardt/simplifile">simplifile</a>, but they are external dependencies.

Other functions that are very useful and I had to code them myself. It was fun to do it. For example, there is a <mark class='bg-gray text-white'>list.at</mark>, but not a <mark class='bg-gray text-white'>string.at</mark>

<h3 class="text-xl mt-8 text-green" id="dictionaries">
Dictionaries
</h3>

The creator even says that dictionaries are not that common to use in Gleam, but I would like to see them not be that secondary.

<h3 class="text-xl mt-8 text-green" id="other">
Other
</h3>

Expressions in functions

This is a syntax error:

<div class="relative">
<pre class="border border-white overflow-x-auto px-4 py-2 mb-8 mt-4"><code class="!bg-black !text-sm language-elixir">
str
|&gt;  string.slice(at_index: index, length: string.length(str)-1)
</code></pre>
<button class="copy-btn absolute -top-1 right-0 m-2 text-sm text-pink bg-transparent cursor-pointer">copy</button>
<div class="absolute -top-1 left-0 m-2 text-sm text-orange"></div>
</div>

Maybe it is a skill issue, but I really think for loops look cleaner than recursion.

<h2 class="text-2xl mt-16 mb-4 text-red font-bold" id="wrapping-up">
Wrapping Up
</h2>

The most accessible functional programming language.

It has changed my mind on how my perfect programming language would be.

Gleam with for loops and early-returns would be my go-to.

<h2 class="text-2xl mt-16 mb-4 text-red font-bold" id="cool-gleam-resources">
Cool Gleam Resources
</h2>

<ul class="list-disc list-outside mb-8 pl-4">
<li><a href="https://tour.gleam.run/">Gleam's Language Tour</a></li>
<li><a href="https://tour.gleam.run/">Gleam's Standard Library Documentation</a></li>
<li><a href="https://github.com/gleam-lang/awesome-gleam">Awesome Gleam: A collection of Gleam libraries, projects, and resources</a></li>
<li><a href="https://github.com/tchojnacki/advent-of-code/tree/main/aoc-2020-gleam">TChojnacki's Advent of Code 2020 solutions</a></li>
<li><a href="https://github.com/vistormu/advent_of_code/tree/master/2020/aoc">My incomplete Advent of Code 2020 solutions</a></li>
</ul>

<div style="height: 120px;"></div>

<div class="absolute left-0 right-0 h-2 bg-pink"></div>

<script src="/js/copyCode.js"></script>
<script> hljs.highlightAll(); </script>
